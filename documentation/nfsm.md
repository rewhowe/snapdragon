# Non-Deterministic Finite State Diagrams / 非決定性有限状態図

The diagrams below describe the different sequences supported by 金魚草's grammar. Each sequence is shown as an flowchart auto-generated by [mermaid](https://mermaid-js.github.io/mermaid/#/), and as a sort of pseudo-regex format.

## ASSIGNMENT

![assignment](./nfsm/assignment.png)

```
BOL
POSSESSIVE ?
ASSIGNMENT
( RVALUE | ( POSSESSIVE PROPERTY ) )
QUESTION ?
(
  COMMA
  ( RVALUE | ( POSSESSIVE PROPERTY ) )
  QUESTION ?
) *
EOL
```

```mermaid
graph LR
  BOL((BOL)) --> POSSESSIVE_1[POSSESSIVE]
  POSSESSIVE_1[POSSESSIVE] --> ASSIGNMENT

  ASSIGNMENT --> RVALUE
  ASSIGNMENT --> POSSESSIVE_2[POSSESSIVE]

  RVALUE --> EOL
  RVALUE --> QUESTION
  RVALUE --> COMMA

  POSSESSIVE_2[POSSESSIVE] --> PROPERTY

  PROPERTY --> EOL
  PROPERTY --> QUESTION
  PROPERTY --> COMMA

  COMMA --> RVALUE
  COMMA --> POSSESSIVE_2[POSSESSIVE]

  QUESTION --> COMMA
  QUESTION --> EOL((EOL))
```

## FUNCTION\_DEF / FUNCTION\_CALL

![function-def](./nfsm/function-def.png)

`BOL PARAMETER * FUNCTION_DEF BANG ? EOL`

```mermaid
graph LR
  BOL((BOL)) --> PARAMETER
  BOL --> FUNCTION_DEF

  PARAMETER --> PARAMETER
  PARAMETER --> FUNCTION_DEF

  FUNCTION_DEF --> EOL((EOL))
  FUNCTION_DEF --> BANG

  BANG --> EOL
```

![function-call](./nfsm/function-call.png)

`BOL ( POSSESSIVE ? PARAMETER ) * FUNCTION_CALL BANG ? QUESTION ? EOL`

```mermaid
graph LR
  BOL((BOL)) --> PARAMETER
  BOL --> FUNCTION_CALL
  BOL --> POSSESSIVE

  PARAMETER --> PARAMETER
  PARAMETER --> FUNCTION_CALL

  FUNCTION_CALL --> EOL((EOL))
  FUNCTION_CALL --> BANG
  FUNCTION_CALL --> QUESTION

  POSSESSIVE --> PARAMETER

  BANG --> QUESTION

  QUESTION --> EOL
```

## RETURN

![return](./nfsm/return.png)

`BOL ( POSSESSIVE ? PARAMETER ) ? RETURN EOL`

```mermaid
graph LR
  BOL((BOL)) --> PARAMETER
  BOL --> POSSESSIVE
  BOL --> RETURN

  PARAMETER --> RETURN

  POSSESSIVE --> PARAMETER

  RETURN --> EOL((EOL))
```

## LOOP / LOOP\_ITERATOR / NEXT / BREAK

![loop](./nfsm/loop.png)

`BOL ( PARAMETER ( PARAMETER | LOOP_ITERATOR ) | NUM_TIMES ) ? LOOP EOL`

```mermaid
graph LR
  BOL((BOL)) --> PARAMETER_1[PARAMETER]
  BOL --> POSSESSIVE_1[POSSESSIVE]
  BOL --> LOOP
  BOL --> NUM_TIMES

  PARAMETER_1[PARAMETER] --> PARAMETER_2[PARAMETER]
  PARAMETER_1[PARAMETER] --> LOOP_ITERATOR
  PARAMETER_1[PARAMETER] --> POSSESSIVE_2[PARAMETER]

  PARAMETER_2[PARAMETER] --> LOOP

  POSSESSIVE_1[POSSESSIVE] --> PARAMETER_1[PARAMETER]

  POSSESSIVE_2[POSSESSIVE] --> PARAMETER_2[PARAMETER]

  LOOP_ITERATOR --> LOOP
  NUM_TIMES --> LOOP

  LOOP --> EOL((EOL))
```

![next](./nfsm/next_break.png)

```mermaid
graph LR
  BOL((BOL)) --> NEXT_BREAK["NEXT / BREAK"]

  NEXT_BREAK --> EOL((EOL))
```

## IF / ELSE\_IF / ELSE

The three main patterns of if-statements are broken up into "Truthy Check", "Comparison", and "Function Call". In reality, these all compose a single, three-branched regex pattern.

### Truthy Check

![if-truthy](./nfsm/if-truthy.png)

`BOL ( IF | ELSE_IF ) ( ... ) * POSSESSIVE ? COMP_1 QUESTION ( COMP_2 | COMP_2_NOT ) EOL`

```
graph LR
  BOL((BOL)) --> IF[IF / ELSE_IF]

  IF --> mcb["..."]
  IF --> COMP_1
  IF --> POSSESSIVE

  mcb --> mcb
  mcb --> COMP_1
  mcb --> POSSESSIVE

  COMP_1 --> QUESTION
  POSSESSIVE --> COMP_1

  QUESTION --> COMP_2["COMP_2<br>/<br>COMP_2_NOT"]

  COMP_2 --> EOL((EOL))

  subgraph multiple condition branch
    mcb
  end
```

![if-truthy-mcb](./nfsm/if-truthy-mcb.png)

`( POSSESSIVE ? COMP_1 QUESTION COMP_2_NOT_CONJ ? COMMA ( AND | OR ) ) *`

```mermaid
graph LR
  subgraph mcb_g["Multiple Condition Branch (Truthy Check)"]

    BOL((...)) --> COMP_1
    BOL --> POSSESSIVE

    subgraph invis
      COMP_1 --> QUESTION
      POSSESSIVE --> COMP_1

      QUESTION --> COMP_2_NOT_CONJ
      QUESTION --> COMMA

      COMP_2_NOT_CONJ --> COMMA

      COMMA --> AND_OR["AND<br>/<br>OR"]
    end

    AND_OR --> EOL((...))

    EOL --> BOL
  end

  classDef outerGraph fill:#fcfcff,stroke:#333,stroke-width:1px;
  class mcb_g outerGraph;
  classDef invis fill:none,stroke:none,opacity:0;
  class invis invis;
```

### Comparison

![if-comparison](./nfsm/if-comparison.png)

```
BOL
( IF | ELSE_IF )
( ... ) *
POSSESSIVE ? SUBJECT
POSSESSIVE ? (
  ( COMP_1 | (COMP_1_TO COMP_1_EQ) | COMP_1_GTEQ | COMP_1_LTEQ | COMP_1_EMP ) ( COMP_2 | COMP_2_NOT )
  | COMP_1_YORI ( COMP_2_LT | COMP_2_GT )
  | COMP_1_IN ( COMP_2_BE | COMP_2_NBE )
)
EOL
```

```mermaid
graph LR
  BOL((BOL)) --> IF[IF / ELSE_IF]

  IF --> mcb["..."]
  IF --> SUBJECT
  IF --> POSSESSIVE_1[POSSESSIVE]

  mcb --> mcb
  mcb --> SUBJECT
  mcb --> POSSESSIVE_1

  SUBJECT --> COMP_1
  SUBJECT --> COMP_1_TO
  SUBJECT --> COMP_1_YORI
  SUBJECT --> COMP_1_LTEQGTEQ["COMP_1_GTEQ<br>/<br>COMP_1_LTEQ"]
  SUBJECT --> POSSESSIVE_2[POSSESSIVE]
  SUBJECT --> COMP_1_EMP
  SUBJECT --> COMP_1_IN

  COMP_1 --> COMP_2["COMP_2<br>/<br>COMP_2_NOT"]

  COMP_1_TO --> COMP_1_EQ
  COMP_1_EQ --> COMP_2

  COMP_1_LTEQGTEQ --> COMP_2

  COMP_1_YORI --> COMP_2_LTGT["COMP_2_LT<br>/<br>COMP_2_GT"]

  COMP_1_EMP --> COMP_2

  COMP_1_IN --> COMP_2_BENBE["COMP_2_BE<br>/<br>COMP_2_NBE"]

  COMP_2 --> EOL((EOL))
  COMP_2_LTGT --> EOL
  COMP_2_BENBE --> EOL

  subgraph subject
    POSSESSIVE_1 --> SUBJECT
  end

  subgraph multiple condition branch
    mcb
  end

  subgraph comparison open
    POSSESSIVE_2 --> COMP_1
    POSSESSIVE_2 --> COMP_1_TO
    POSSESSIVE_2 --> COMP_1_YORI
    POSSESSIVE_2 --> COMP_1_LTEQGTEQ
    COMP_1_EQ
    COMP_1_EMP
    COMP_1_IN
  end

  subgraph comparison close
    COMP_2
    COMP_2_LTGT
    COMP_2_BENBE
  end
```

![if-comparison-mcb](./nfsm/if-comparison-mcb.png)

```
(
  POSSESSIVE ? SUBJECT
  POSSESSIVE ? (
    ( COMP_1 | ( COMP_1_TO COMP_1_EQ ) | COMP_1_GTEQ | COMP_1_LTEQ | COMP_1_EMP ) ( COMP_2_CONJ | COMP_2_NOT_CONJ )
    | COMP_1_YORI ( COMP_2_LT_CONJ | COMP_2_GT_CONJ )
    | COMP_1_IN ( COMP_2_BE_CONJ | COMP_2_NBE_CONJ )
  )
  COMMA
  ( AND | OR )
) *
```

```mermaid
graph LR
  subgraph mcb_g["Multiple Condition Branch (Comparison)"]
    BOL((...)) --> SUBJECT
    BOL --> POSSESSIVE_1[POSSESSIVE]

    SUBJECT --> COMP_1
    SUBJECT --> COMP_1_TO
    SUBJECT --> COMP_1_YORI
    SUBJECT --> COMP_1_LTEQGTEQ["COMP_1_GTEQ<br>/<br>COMP_1_LTEQ"]
    SUBJECT --> POSSESSIVE_2[POSSESSIVE]
    SUBJECT --> COMP_1_EMP
    SUBJECT --> COMP_1_IN

    COMP_1 --> COMP_2["COMP_2_CONJ<br>/<br>COMP_2_NOT_CONJ"]

    COMP_1_TO --> COMP_1_EQ
    COMP_1_EQ --> COMP_2

    COMP_1_LTEQGTEQ --> COMP_2

    COMP_1_YORI --> COMP_2_LTGT["COMP_2_LT_CONJ<br>/<br>COMP_2_GT_CONJ"]

    COMP_1_EMP --> COMP_2

    COMP_1_IN --> COMP_2_BENBE["COMP_2_BE_CONJ<br>/<br>COMP_2_NBE_CONJ"]

    COMP_2 --> COMMA
    COMP_2_LTGT --> COMMA
    COMP_2_BENBE --> COMMA

    COMMA --> AND_OR["AND<br>/<br>OR"]

    AND_OR --> EOL((...))

    EOL --> BOL

    subgraph subject
        POSSESSIVE_1 --> SUBJECT
    end

    subgraph comparison open
        POSSESSIVE_2 --> COMP_1
        POSSESSIVE_2 --> COMP_1_TO
        POSSESSIVE_2 --> COMP_1_YORI
        POSSESSIVE_2 --> COMP_1_LTEQGTEQ
        COMP_1_EQ
        COMP_1_EMP
        COMP_1_IN
    end

    subgraph comparison close
        COMP_2
        COMP_2_LTGT
        COMP_2_BENBE
    end
  end

  classDef outerGraph fill:#fcfcff,stroke:#333,stroke-width:1px;
  class mcb_g outerGraph;
```

### Function Call

![if-function-call](./nfsm/if-function-call.png)

```
BOL
( IF | ELSE_IF )
( ... ) *
( POSSESSIVE ? PARAMETER ) * FUNCTION_CALL BANG ? QUESTION ?
( COMP_2 | COMP_2_NOT )
EOL
```

```mermaid
graph LR
  BOL((BOL)) --> IF[IF / ELSE_IF]

  IF --> mcb["..."]
  IF --> POSSESSIVE
  IF --> PARAMETER
  IF --> FUNCTION_CALL

  mcb --> mcb
  mcb --> POSSESSIVE
  mcb --> PARAMETER
  mcb --> FUNCTION_CALL

  PARAMETER --> POSSESSIVE
  PARAMETER --> PARAMETER
  PARAMETER --> FUNCTION_CALL

  POSSESSIVE --> PARAMETER

  FUNCTION_CALL --> BANG
  FUNCTION_CALL --> QUESTION
  FUNCTION_CALL --> COMP_2["COMP_2<br>/<br>COMP_2_NOT"]

  BANG --> QUESTION
  BANG --> COMP_2

  QUESTION --> COMP_2

  COMP_2 --> EOL((EOL))

  subgraph multiple condition branch
    mcb
  end
```

![if-function-call-mcb](./nfsm/if-function-call-mcb.png)

`( ( POSSESSIVE ? PARAMETER ) * FUNCTION_CALL BANG ? QUESTION ? COMP_2_NOT ? ) *`

```mermaid
graph LR
  subgraph mcb_g["Multiple Condition Branch (Function Call)"]
    BOL((...)) --> POSSESSIVE
    BOL --> PARAMETER
    BOL --> FUNCTION_CALL

    subgraph invis
      PARAMETER --> POSSESSIVE
      PARAMETER --> PARAMETER
      PARAMETER --> FUNCTION_CALL

      POSSESSIVE --> PARAMETER

      FUNCTION_CALL --> COMP_2_NOT_CONJ
      FUNCTION_CALL --> QUESTION
      FUNCTION_CALL --> BANG

      BANG --> QUESTION
      BANG --> COMP_2_NOT_CONJ

      QUESTION --> COMP_2_NOT_CONJ
    end

    COMP_2_NOT_CONJ --> EOL
    QUESTION --> EOL
    BANG --> EOL((...))

    EOL --> BOL
  end

  classDef outerGraph fill:#fcfcff,stroke:#333,stroke-width:1px;
  class mcb_g outerGraph;
  classDef invis fill:none,stroke:none,opacity:0;
  class invis invis;
```

### Else

![else](./nfsm/else.png)

```mermaid
graph LR
  BOL((BOL)) --> ELSE

  ELSE --> EOL((EOL))
```

## WHILE (LOOP)

(Combination of IF / ELSE\_IF and LOOP)

![while](./nfsm/while.png)

```
BOL
( ... ) *
(
  POSSESSIVE ? COMP_1 QUESTION ( COMP_2_TRUE_MOD | COMP_2_FALSE_MOD )
  | ( POSSESSIVE ? PARAMETER ) * FUNCTION_CALL BANG ? QUESTION ? COMP_2_NOT_MOD ?
  | POSSESSIVE ? SUBJECT POSSESSIVE ? (
    ( COMP_1 | ( COMP_1_TO COMP_1_EQ ) | COMP_1_GTEQ | COMP_1_LTEQ | COMP_1_EMP ) ( COMP_2_MOD | COMP_2_NOT_MOD )
    | COMP_1_YORI ( COMP_2_LT_MOD | COMP_2_GT_MOD )
    | COMP_1_IN ( COMP_2_BE_MOD | COMP_2_NBE_MOD )
  )
)
WHILE
LOOP
EOL
```

Multiple condition branch uses the same states as IF / ELSE\_IF.

```mermaid
graph LR
  BOL((BOL)) --> mcb["..."]

  BOL --> TRUTHY_COMP_1[COMP_1]
  BOL --> TRUTHY_POSSESSIVE[POSSESSIVE]
  BOL --> SUBJECT
  BOL --> POSSESSIVE_1[POSSESSIVE]

  mcb --> TRUTHY_COMP_1
  mcb --> TRUTHY_POSSESSIVE

  TRUTHY_COMP_1 --> TRUTHY_QUESTION[QUESTION]
  TRUTHY_POSSESSIVE --> TRUTHY_COMP_1

  TRUTHY_QUESTION --> TRUTHY_COMP_2["COMP_2_TRUE_MOD<br>/<br>COMP_2_FALSE_MOD"]

  TRUTHY_COMP_2 --> WHILE

  BOL --> FUNCTIONAL_POSSESSIVE[POSSESSIVE]
  BOL --> FUNCTIONAL_PARAMETER[PARAMETER]
  BOL --> FUNCTION_CALL

  mcb --> FUNCTIONAL_POSSESSIVE
  mcb --> FUNCTIONAL_PARAMETER
  mcb --> FUNCTION_CALL

  FUNCTIONAL_PARAMETER --> FUNCTIONAL_POSSESSIVE
  FUNCTIONAL_PARAMETER --> FUNCTIONAL_PARAMETER
  FUNCTIONAL_PARAMETER --> FUNCTION_CALL

  FUNCTIONAL_POSSESSIVE --> FUNCTIONAL_PARAMETER

  FUNCTION_CALL --> FUNCTIONAL_BANG[BANG]
  FUNCTION_CALL --> FUNCTIONAL_QUESTION[QUESTION]
  FUNCTION_CALL --> FUNCTIONAL_COMP_2_NOT_MOD[COMP_2_NOT_MOD]

  FUNCTIONAL_BANG --> FUNCTIONAL_QUESTION
  FUNCTIONAL_BANG --> FUNCTIONAL_COMP_2_NOT_MOD

  FUNCTIONAL_QUESTION --> FUNCTIONAL_COMP_2_NOT_MOD

  FUNCTIONAL_COMP_2_NOT_MOD --> WHILE
  FUNCTIONAL_BANG --> WHILE
  FUNCTIONAL_QUESTION --> WHILE

  mcb --> mcb
  mcb --> SUBJECT
  mcb --> POSSESSIVE_1

  SUBJECT --> COMP_1
  SUBJECT --> COMP_1_TO
  SUBJECT --> COMP_1_YORI
  SUBJECT --> COMP_1_LTEQGTEQ["COMP_1_GTEQ<br>/<br>COMP_1_LTEQ"]
  SUBJECT --> POSSESSIVE_2[POSSESSIVE]
  SUBJECT --> COMP_1_EMP
  SUBJECT --> COMP_1_IN

  COMP_1 --> COMP_2["COMP_2_MOD<br>/<br>COMP_2_NOT_MOD"]

  COMP_1_TO --> COMP_1_EQ
  COMP_1_EQ --> COMP_2

  COMP_1_LTEQGTEQ --> COMP_2

  COMP_1_YORI --> COMP_2_LTGT["COMP_2_LT_MOD<br>/<br>COMP_2_GT_MOD"]

  COMP_1_EMP --> COMP_2

  COMP_1_IN --> COMP_2_BENBE["COMP_2_BE_MOD<br>/<br>COMP_2_NBE_MOD"]

  COMP_2 --> WHILE
  COMP_2_LTGT --> WHILE
  COMP_2_BENBE --> WHILE

  WHILE --> LOOP
  LOOP --> EOL((EOL))

  subgraph subject
    POSSESSIVE_1 --> SUBJECT
  end

  subgraph multiple condition branch
    mcb
  end

  subgraph truthy condition
    TRUTHY_POSSESSIVE
    TRUTHY_COMP_1
    TRUTHY_QUESTION
    TRUTHY_COMP_2
  end

  subgraph functional condition
    FUNCTIONAL_POSSESSIVE
    FUNCTIONAL_PARAMETER
    FUNCTION_CALL
    FUNCTIONAL_COMP_2_NOT_MOD
    FUNCTIONAL_BANG
    FUNCTIONAL_QUESTION
  end

  subgraph comparison open
    POSSESSIVE_2 --> COMP_1
    POSSESSIVE_2 --> COMP_1_TO
    POSSESSIVE_2 --> COMP_1_YORI
    POSSESSIVE_2 --> COMP_1_LTEQGTEQ
    COMP_1_EQ
    COMP_1_EMP
    COMP_1_IN
  end

  subgraph comparison close
    COMP_2
    COMP_2_LTGT
    COMP_2_BENBE
  end
```

## MISC

![no-op](./nfsm/no-op.png)

```mermaid
graph LR
  BOL((BOL)) --> NO_OP

  NO_OP --> EOL((EOL))
```

![debug](./nfsm/debug.png)

```mermaid
graph LR
  BOL((BOL)) --> DEBUG

  DEBUG --> BANG
  DEBUG --> EOL((EOL))

  BANG --> EOL
```
